<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Positive Match Tool</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Arial;margin:0;line-height:1.6}
    main{max-width:980px;margin:0 auto;padding:28px}
    .card{border:1px solid #00000022;border-radius:16px;padding:16px;margin:14px 0}
    .muted{opacity:.75}
    img{max-width:100%;border-radius:14px}
    .row{display:grid;gap:14px}
    @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
    .btn{border:1px solid #00000022;border-radius:12px;padding:10px 14px;background:#fff;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .line{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px}
  </style>
</head>
<body>
<main>
  <a href="../" class="muted">← Back</a>
  <h1>Find the closest match</h1>
  <p class="muted">Runs in your browser, then uploads your image + logs the result.</p>

  <div class="row">
    <div class="card">
      <h2>Your image</h2>
      <input id="file" type="file" accept="image/*" />
      <div class="line">
        <label class="muted" style="display:flex;gap:8px;align-items:center;">
          <input id="consent" type="checkbox" />
          I consent to upload this image for storage and logging the match result.
        </label>
      </div>

      <p class="muted" id="status"></p>
      <div class="line">
        <button class="btn" id="match" disabled>Match + Upload</button>
        <button class="btn" id="reset">Reset</button>
      </div>
    </div>

    <div class="card">
      <h2>Closest result</h2>
      <img id="bestImg" style="display:none" alt="best match" />
      <p id="bestText" class="muted">No match yet.</p>
      <p class="muted" id="bestMeta"></p>
    </div>
  </div>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

    const SUPABASE_URL = "https://jjlptblaycehiibommaz.supabase.co";
    const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpqbHB0YmxheWNlaGlpYm9tbWF6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk4Mzg3NzEsImV4cCI6MjA4NTQxNDc3MX0.sSZwDFb8rQBgBq857HWNUVKIBeXwvhEqmyM8-Q6kY0I";
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON);

    const fileEl = document.getElementById('file');
    const consentEl = document.getElementById('consent');
    const statusEl = document.getElementById('status');
    const bestImg = document.getElementById('bestImg');
    const bestText = document.getElementById('bestText');
    const bestMeta = document.getElementById('bestMeta');
    const matchBtn = document.getElementById('match');
    const resetBtn = document.getElementById('reset');

    let imgBitmap = null;
    let pickedFile = null;

    function updateMatchEnabled(){
      matchBtn.disabled = !(pickedFile && imgBitmap && consentEl.checked);
    }

    function popcount64BigInt(x){
      let c = 0n;
      while(x){ x &= (x - 1n); c++; }
      return Number(c);
    }

    function dhashFromBitmap(bitmap, size=8){
      const w = size + 1, h = size;
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const ctx = c.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(bitmap, 0, 0, w, h);
      const data = ctx.getImageData(0,0,w,h).data;

      let bits = 0n;
      for(let y=0; y<h; y++){
        for(let x=0; x<size; x++){
          const i1 = (y*w + x) * 4;
          const i2 = (y*w + x + 1) * 4;
          const g1 = data[i1]*0.299 + data[i1+1]*0.587 + data[i1+2]*0.114;
          const g2 = data[i2]*0.299 + data[i2+1]*0.587 + data[i2+2]*0.114;
          bits = (bits << 1n) | (g1 > g2 ? 1n : 0n);
        }
      }
      return bits;
    }

    async function loadJson(path){
      const r = await fetch(path, { cache: 'no-store' });
      if(!r.ok) throw new Error("Failed to load " + path);
      return await r.json();
    }

    function guessExt(file){
      const name = (file?.name || "").toLowerCase();
      const parts = name.split(".");
      if(parts.length > 1){
        const ext = parts.pop();
        if(["jpg","jpeg","png","webp","gif","bmp"].includes(ext)) return ext;
      }
      const t = (file?.type || "").toLowerCase();
      if(t.includes("png")) return "png";
      if(t.includes("webp")) return "webp";
      if(t.includes("gif")) return "gif";
      return "jpg";
    }

    async function uploadAndLog({ file, matchId, matchDistance }){
      if(file.size > 10 * 1024 * 1024){
        throw new Error("File too large (max 10MB).");
      }

      const ext = guessExt(file);
      const objectPath = `incoming/${crypto.randomUUID()}.${ext}`;

      const { error: upErr } = await supabase
        .storage.from("uploads")
        .upload(objectPath, file, { contentType: file.type || "application/octet-stream", upsert: false });

      if(upErr) throw new Error("Upload failed: " + upErr.message);

      const { error: logErr } = await supabase
        .from("uploads_log")
        .insert([{
          object_path: objectPath,
          content_type: file.type || null,
          size_bytes: file.size,
          consent: true,
          match_id: matchId,
          match_distance: matchDistance
        }]);

      if(logErr) throw new Error("Log failed: " + logErr.message);

      return objectPath;
    }

    fileEl.addEventListener('change', async () => {
      const f = fileEl.files && fileEl.files[0];
      pickedFile = f || null;
      imgBitmap = null;

      if(!pickedFile){
        statusEl.textContent = "";
        updateMatchEnabled();
        return;
      }

      statusEl.textContent = "Loading image…";
      imgBitmap = await createImageBitmap(pickedFile);
      statusEl.textContent = "Ready. Check consent, then Match.";
      updateMatchEnabled();
    });

    consentEl.addEventListener('change', updateMatchEnabled);

    resetBtn.addEventListener('click', () => {
      fileEl.value = "";
      pickedFile = null;
      imgBitmap = null;
      bestImg.style.display = 'none';
      bestText.textContent = "No match yet.";
      bestMeta.textContent = "";
      statusEl.textContent = "";
      consentEl.checked = false;
      updateMatchEnabled();
    });

    matchBtn.addEventListener('click', async () => {
      try{
        if(!imgBitmap || !pickedFile){ statusEl.textContent = "Upload an image first."; return; }
        if(!consentEl.checked){ statusEl.textContent = "Consent is required."; return; }

        const t0 = performance.now();

        statusEl.textContent = "Loading dataset…";
        const [hashes, labels] = await Promise.all([
          loadJson("../dataset/hashes.json"),
          loadJson("../dataset/labels.json")
        ]);

        statusEl.textContent = "Matching…";
        const myHash = dhashFromBitmap(imgBitmap);

        let bestName = null;
        let bestDist = 999;

        for(const [name, hex] of Object.entries(hashes)){
          const h = BigInt("0x" + hex);
          const dist = popcount64BigInt(myHash ^ h);
          if(dist < bestDist){
            bestDist = dist;
            bestName = name;
            if(bestDist === 0) break;
          }
        }

        if(!bestName){
          bestText.textContent = "No match found.";
          statusEl.textContent = "No match found.";
          return;
        }

        statusEl.textContent = "Uploading + logging…";
        const objectPath = await uploadAndLog({
          file: pickedFile,
          matchId: bestName,
          matchDistance: bestDist
        });

        const t1 = performance.now();
        const ms = Math.round(t1 - t0);

        bestImg.src = `../dataset/images/${bestName}`;
        bestImg.style.display = 'block';
        bestText.textContent = labels[bestName] || "You’ve got this. Keep going.";
        bestMeta.textContent = `Match: ${bestName} • Distance: ${bestDist} • Time: ${ms}ms • Stored: ${objectPath}`;

        statusEl.textContent = "Done.";
      }catch(e){
        statusEl.textContent = "Error: " + (e?.message || e);
      }
    });

    updateMatchEnabled();
  </script>
</main>
</body>
</html>
